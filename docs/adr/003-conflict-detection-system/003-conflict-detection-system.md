# 충돌 탐지 시스템: Linked List of Hashes

## 핵심 결정: Git 방식의 버전 체인 추적

`my-commit` 프로젝트는 로컬과 서버 간의 데이터 동기화에서 발생하는 충돌을 정확하게 감지하고 해결하기 위해, 단순한 타임스탬프 비교 대신 Git과 유사한 Linked List of Hashes 방식을 채택했습니다.

---

## 3가지 핵심 개념

충돌 탐지 시스템은 다음 세 가지 핵심 개념으로 구성됩니다.

| 개념             | 설명                                         | 역할                                       |
| :--------------- | :------------------------------------------- | :----------------------------------------- |
| Content Hash     | 각 버전의 내용을 FNV-1a 알고리즘으로 해시화  | 버전의 고유 식별자, 빠른 동등성 비교       |
| Parent Hash      | 이전 버전의 해시를 참조                      | 버전 체인 형성, 변경 이력 추적             |
| Linked List 구조 | 각 버전이 부모를 가리키는 단방향 연결 리스트 | Git과 유사한 버전 히스토리, 분기 감지 가능 |

---

## 비교 분석

### vs Timestamp 기반 충돌 감지

타임스탬프(`updatedAt`)만 사용하는 전통적인 방식과의 비교입니다.

| 항목           | Timestamp 방식 (updatedAt)             | Hash Chain 방식 (Linked List)        |
| :------------- | :------------------------------------- | :----------------------------------- |
| 충돌 판단 기준 | 최신 타임스탬프 우선 (Last-Write-Wins) | 버전 체인 분석 (부모-자식 관계 확인) |
| 데이터 보존    | ❌ 오판 시 데이터 손실 위험            | ✅ 분기 감지로 데이터 보존           |
| 오프라인 지원  | ❌ 클라이언트 시간 차이로 오작동 가능  | ✅ 내용 기반 판단으로 시간 무관      |
| 구현 복잡도    | 단순 (타임스탬프 비교만)               | 중간 (해시 계산 + 체인 추적)         |
| 실제 충돌 감지 | ❌ Fast-forward 상황을 충돌로 오판     | ✅ Fast-forward와 실제 충돌 구분     |

#### Timestamp 방식의 치명적 문제 사례

```
시나리오:
1. 서버: "A" (10:00)
2. 클라 1: "A" (변경 없음, 10:05에 페이지 접속)
3. 클라 2: "A" → "C" (서버 저장, 10:03)

updatedAt 비교:
  local (10:05) > server (10:03)
  → 로컬 승리
  → "A" 선택
  → 서버의 "C"가 사라짐! ❌
```

#### Hash Chain 방식의 해결

```
같은 시나리오:
1. 서버: "A" (hash: "abc")
2. 클라 1: "A" (hash: "abc", parent: null)
3. 클라 2: "C" (hash: "xyz", parent: "abc")

Hash 비교:
  local.hash ("abc") ≠ server.hash ("xyz")
  server.parent ("abc") === local.hash ("abc")
  → Fast-forward!
  → 서버 승리 ("C" 선택)
  → 데이터 보존! ✅
```

---

## 충돌 감지 알고리즘

시스템은 4가지 케이스를 자동으로 판별합니다.

| 케이스            | 조건                              | 처리 방식            | 사용자 개입 |
| :---------------- | :-------------------------------- | :------------------- | :---------- |
| NO_CONFLICT_SAME  | `localHash === serverHash`        | 아무 작업 불필요     | ❌          |
| FAST_FORWARD      | `serverParent === localHash`      | 서버 버전 사용       | ❌          |
| LOCAL_AHEAD       | `localParent === serverHash`      | 로컬 버전 업로드     | ❌          |
| CONFLICT_DIVERGED | 공통 조상에서 분기 또는 연결 끊김 | 충돌 다이얼로그 표시 | ✅ 필요     |

---

## 단점 및 한계

도입 시 고려했던 Hash Chain 방식의 단점들과 이에 대한 대응책입니다.

### 1. 해시 충돌 가능성

- FNV-1a는 SHA-256보다 빠르지만 충돌 확률이 상대적으로 높습니다.
- 대응: 실제 로그 데이터 특성상 충돌 가능성이 극히 낮으며, 필요 시 SHA-256으로 전환 가능합니다.

### 2. 자동 Merge 미지원

- Git의 3-way merge와 달리 자동 병합 기능이 없습니다.
- 대응: 사용자 데이터 보호를 최우선으로, 충돌 시 명시적으로 사용자가 선택하도록 설계했습니다.

### 3. 다중 분기 추적 제한

- Git의 merge commit (두 부모 추적)과 달리 단일 부모만 추적합니다.
- 대응: 로그 데이터의 특성상 복잡한 merge 히스토리가 불필요하며, 단순한 체인만으로도 충분합니다.

### 4. 추가 저장 공간 필요

- `contentHash`와 `parentHash` 필드를 추가로 저장해야 합니다.
- 대응: 해시는 8바이트 정도의 작은 문자열이며, 데이터 보존이라는 이점에 비해 무시할 수 있는 오버헤드입니다.

### 5. 기존 데이터 마이그레이션

- 기존 사용자의 데이터에는 해시 정보가 없습니다.
- 대응: 자동 마이그레이션 로직으로 기존 데이터에 `contentHash` 계산 및 `parentHash: null` 설정을 수행합니다.

---

## 결론

`my-commit`은 사용자의 시간 로그 데이터를 다루는 만큼, 데이터 보존이 가장 중요한 가치입니다.

Timestamp 방식은 구현이 단순하지만 Fast-forward 상황을 오판하여 데이터를 잃을 수 있습니다. 반면 Hash Chain 방식은 약간의 복잡도 증가와 저장 공간 오버헤드가 있지만, 버전 체인을 추적하여 실제 충돌과 자동 해결 가능한 상황을 정확히 구분할 수 있습니다.

### 선택한 방식

- 충돌 감지: Linked List of Hashes (Content Hash + Parent Hash)
- 해시 알고리즘: FNV-1a (빠른 계산 속도, 충분한 유니크성)
- 충돌 해결: 사용자 명시적 선택 (자동 merge 미지원)

이 조합을 통해 오프라인 작업을 안전하게 지원하며, 여러 기기에서 동시에 작업하더라도 사용자 데이터를 보호합니다.

---

## 관련 문서

- [충돌 탐지 시스템 상세 문서](../CONFLICT_DETECTION.md)
- [테스트 가이드](../TESTING.md)
